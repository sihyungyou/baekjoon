/*
문제 설명
자연수로 이루어진 수열이 주어질 때, 이 수열에서 같은 값이 연속해서 나오는 개수를 순서대로 나열하는 과정을 반복하려 합니다.

예를 들어 수열이 [1, 1, 3, 3, 2, 2, 4, 5, 1, 1, 1, 3, 3, 3]일 때, 같은 값이 연속해서 나오는 개수를 순서대로 나열하면 [2, 2, 2, 1, 1, 3, 3]이 됩니다. 새로 구한 수열에서 다시 같은 값이 연속해서 나오는 개수를 순서대로 나열하면 [3, 2, 2]가 됩니다. 마찬가지 작업을 계속 반복하면 수열은 다음과 같이 변합니다.

[3, 2, 2] → [1, 2] → [1, 1] → [2] → [1] → [1] → [1] ...

이와 같이 처음 주어진 수열에 같은 값이 연속해서 나오는 개수를 순서대로 나열하는 과정을 계속해서 수행하면 마지막에는 [1]이 무한히 반복됩니다.

초기 수열 값들이 주어질 때, 최초로 [1]이라는 수열이 나올 때까지 과정을 몇 번 수행했는지 구해주세요.

제한사항
입력 :

표준 입력을 사용해 데이터를 입력받으세요.
테스트 케이스 첫째 줄에 수열의 길이 N이 주어집니다.
N은 1 이상 1,000 이하인 자연수입니다.
테스트 케이스 둘째 줄에 수열에 들어있는 자연수 N개가 순서대로 주어집니다.
수열에 들어있는 자연수는 1 이상 1,000 이하입니다.
출력 :

표준 출력을 사용해 정답을 출력해주세요.
최초로 [1]이라는 수열이 나올 때까지 과정을 몇 번 수행했는지 출력해주세요.
*/
#include <cstdio>
#include <vector>

using namespace std;

int main(void) {
    int i, j, n, temp, ans = 0, cnt = 1, tempi;
    vector <vector<int> > v(2);

    scanf("%d", &n);
    
    for (i = 0; i < n; i++) {
        scanf("%d", &temp);
        v[1].push_back(temp);
    }
    
    i = 1;
    bool flag = true;
    
    while(1) {
        if ( (v[0].size() == 1 && v[0][0] == 1) || (v[1].size() == 1 && v[1][0] == 1) ) break;

        cnt = 1;
        flag = true;
        tempi = i+1;
        
        for (j = 0; j < v[i%2].size(); j++) {
            if (j == v[i%2].size()-1) {
                v[tempi%2].push_back(cnt);
                break;
            }
            if (v[i%2][j] == v[i%2][j+1]) cnt++;
            else {
                v[tempi%2].push_back(cnt);
                cnt = 1;
            }
        }
        i++;
        ans++;

    }
    
    printf("%d\n", ans++);
    
    return 0;
}